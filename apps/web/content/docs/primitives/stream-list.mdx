---
title: Stream.List
description: Render arrays that grow as data streams in.
---

`Stream.List` takes an array and renders it with a fallback while loading. It automatically filters out incomplete items during streaming.

## Demo

<DemoPreview>
  <StreamListDemo />
</DemoPreview>

## Usage

```tsx
import { Stream } from "@stream.ui/react";

const { object, isLoading } = useObject({ schema: mySchema });

<Stream.Root data={object} isLoading={isLoading}>
  <Stream.List
    items={object?.forecast}
    fallback={
      <div className="grid grid-cols-3 gap-4">
        {[0, 1, 2].map((i) => (
          <Skeleton key={i} className="h-20" />
        ))}
      </div>
    }
  >
    {(days) => (
      <div className="grid grid-cols-3 gap-4">
        {days.map((day) => (
          <ForecastDay key={day.id} {...day} />
        ))}
      </div>
    )}
  </Stream.List>
</Stream.Root>
```

## Anatomy

```tsx
import { Stream } from "@stream.ui/react";

<Stream.List items={array} fallback={<Fallback />}>
  {(items) => items.map(item => <Item key={item.id} {...item} />)}
</Stream.List>
```

## Examples

### Basic List

```tsx
<Stream.List items={object?.results} fallback={<ResultsSkeleton />}>
  {(results) => (
    <ul className="space-y-2">
      {results.map((result) => (
        <li key={result.id}>{result.title}</li>
      ))}
    </ul>
  )}
</Stream.List>
```

### Grid Layout

```tsx
import { Skeleton } from "@/components/ui/skeleton";

<Stream.List
  items={object?.products}
  fallback={
    <div className="grid grid-cols-3 gap-4">
      {[0, 1, 2, 3, 4, 5].map((i) => (
        <Skeleton key={i} className="h-48 rounded-xl" />
      ))}
    </div>
  }
>
  {(products) => (
    <div className="grid grid-cols-3 gap-4">
      {products.map((product) => (
        <ProductCard key={product.id} {...product} />
      ))}
    </div>
  )}
</Stream.List>
```

### Nested Arrays

```tsx
<Stream.List items={object?.user?.posts} fallback={<PostsSkeleton />}>
  {(posts) => posts.map(post => <PostCard key={post.id} post={post} />)}
</Stream.List>
```

### With Empty State

Handle empty arrays by checking length:

```tsx
<Stream.List items={object?.notifications} fallback={<NotificationsSkeleton />}>
  {(notifications) => 
    notifications.length === 0 ? (
      <EmptyState message="No notifications" />
    ) : (
      notifications.map(n => <Notification key={n.id} {...n} />)
    )
  }
</Stream.List>
```

## How It Works

As the array streams in, items appear incrementally:

```
t=0: fallback shown (array undefined)
t=1: fallback shown (empty array [])
t=2: children([item1])
t=3: children([item1, item2])
...
```

The component automatically filters out `undefined` and empty items that may appear during streaming. The fallback is shown until at least one valid item exists.

## API Reference

### Props

| Prop | Type | Default |
| --- | --- | --- |
| `items` | `T[] \| undefined` | — |
| `fallback` | `ReactNode` | `null` |
| `children` | `(items: T[]) => ReactNode` | — |
